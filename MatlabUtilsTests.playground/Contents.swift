//: Playground - noun: a place where people can play

import UIKit
import CSV
import Accelerate
import simd
//import MatlabUtils

var str = "Hello, playground"

let fileURL = Bundle.main.url(forResource: "sensors", withExtension: "csv")
let csvString = try String(contentsOf: fileURL!, encoding: String.Encoding.utf8)

var samplePeriod = 1/50.0;
var time = [Double]()
var gyrX = [Double]()
var gyrY = [Double]()
var gyrZ = [Double]()
var accX = [Double]()
var accY = [Double]()
var accZ = [Double]()

//let csv = try! CSVReader(string: csvString, hasHeaderRow: true)
//            while let row = csv.next() {
//                print(row)
//            }

//let csv = try! CSVReader(string: csvString)
let csv = try! CSVReader(string: csvString, hasHeaderRow: true) // It must be true.

//while let row = csv.next() {
//    print("\(row)")
//}

//let headerRow = csv.headerRow!
//print("\(headerRow)") // => ["id", "name"]
while csv.next() != nil {
    time.append(Double(csv["Time (s)"]!)!)
    gyrX.append(Double(csv["Gyroscope X (deg/s)"]!)!)
    gyrY.append(Double(csv["Gyroscope Y (deg/s)"]!)!)
    gyrZ.append(Double(csv["Gyroscope Z (deg/s)"]!)!)
    accX.append(Double(csv["Accelerometer X (g)"]!)!)
    accY.append(Double(csv["Accelerometer Y (g)"]!)!)
    accZ.append(Double(csv["Accelerometer Z (g)"]!)!)
    //                print("\(csv["Time (s)"]!)")
    //    if(time.count == 500) {
    //        break
    //    }
}

//% Compute accelerometer magnitude
//acc_mag = sqrt(accX.*accX + accY.*accY + accZ.*accZ);
var accX2 = [Double](repeating: 0.0, count: accX.count)
vDSP_vmulD(accX, 1, accX, 1, &accX2, 1, vDSP_Length(accX.count))
var accY2 = [Double](repeating: 0.0, count: accY.count)
vDSP_vmulD(accY, 1, accY, 1, &accY2, 1, vDSP_Length(accY.count))
var accZ2 = [Double](repeating: 0.0, count: accZ.count)
vDSP_vmulD(accZ, 1, accZ, 1, &accZ2, 1, vDSP_Length(accZ.count))
var temp = [Double](repeating: 0.0, count: time.count)
vDSP_vaddD(accX2, 1, accY2, 1, &temp, 1, vDSP_Length(accX2.count))
var temp2 = [Double](repeating: 0.0, count: time.count)
vDSP_vaddD(temp, 1, accZ2, 1, &temp2, 1, vDSP_Length(temp.count))
var acc_mag = [Double](repeating: 0.0, count: time.count)
var count = Int32(temp2.count)
vvsqrt(&acc_mag, temp2, &count)

//print(acc_mag)
// a & b arrays generated by the Matlab command '[b, a] = butter(10, 2.0/25)'
//[b1, a1] = butter(1, (2*0.001)/(1/(1/50)), 'high');
let b1:[Double] = [0.999937172094439,-0.999937172094439]
let a1:[Double] = [1,-0.999874344188878]
// a & b arrays generated by the Matlab command '[b, a] = butter(10, 2.0/25)'
//[b2, a2] = butter(1, (2*5)/(1/(1/50)), 'low');
let b2:[Double] = [0.245237275252786,0.245237275252786]
let a2:[Double] = [1,-0.509525449494429]
//print(acc_mag)
var acc_magFilt = filtfilt(a:a1, b:b1, x:acc_mag);
var acc_magFiltNew = filtfilt(a:a2, b:b2, x:acc_magFilt);

//% Threshold detection
//print(acc_magFiltNew)
//stationary = acc_magFilt < 0.05

var stationary = [Int](repeating: 0, count: time.count)
for (i, iacc_magFilt) in zip(acc_magFiltNew.indices, acc_magFiltNew) {
    if iacc_magFilt < 0.05 {
        stationary[i] = 1
    }
}
//print(stationary)

//% Compute orientation
//quat = zeros(length(time), 4);
var quat = [[Double]]()
for i in 0...time.count-1 {
    quat.append([0,0,0,0])
}
var AHRSalgorithm = AHRS(SamplePeriod:samplePeriod, Kp:1, KpInit:1)
let initPeriod:Double = 2;
var indexSelEnd = 0;
for (i, itime) in zip(time.indices, time) {
    if (itime - (time[0]+initPeriod)) > 0 {
        indexSelEnd = i
        break
    }
}

///% Initial convergence
let indexSel = (0..<indexSelEnd+1)
let accXSel = Array(accX[indexSel])
let accYSel = Array(accY[indexSel])
let accZSel = Array(accZ[indexSel])
let meanOfAccXSel = mean(a:accXSel)
let meanOfAccYSel = mean(a:accYSel)
let meanOfAccZSel = mean(a:accZSel)
for i in 0...1999 {
    let zeros3:[Double] = [0.0,0.0,0.0]
    let meanOfAcc:[Double] = [meanOfAccXSel,meanOfAccYSel,meanOfAccZSel]
    AHRSalgorithm.UpdateIMU(Gyroscope:zeros3, Accelerometer:meanOfAcc)
}

//% For all data
for t in 0...time.count-1 {
    if (stationary[t] == 1) {
        AHRSalgorithm.Kp = 0.5
    }
    else {
        AHRSalgorithm.Kp = 0
    }
    AHRSalgorithm.UpdateIMU(Gyroscope:[deg2rad(D:gyrX[t]),deg2rad(D:gyrY[t]),deg2rad(D:gyrZ[t])], Accelerometer:[accX[t],accY[t],accZ[t]]);
    quat[t] = AHRSalgorithm.Quaternion
}

//% -------------------------------------------------------------------------
//% Compute translational accelerations
//% Rotate body accelerations to Earth frame
var acc:[[Double]] = []
for i in 0...accX.count-1 {
    let iacc:[Double] = [accX[i],accY[i],accZ[i]]
    acc.append(iacc)
}
acc = quaternRotate(v:acc,q:quaternConj(q:quat))
//% Convert acceleration measurements to m/s/s
for i in 0...acc.count-1 {
    for j in 0...acc[i].count-1 {
        acc[i][j] = acc[i][j] * 9.81
    }
}

//% Compute translational velocities
//acc(:,3) = acc(:,3) - 9.81;
for i in 0...acc.count - 1{
    acc[i][2] = acc[i][2] - 9.81
}

//% Integrate acceleration to yield velocity
var vel:[[Double]] = []
for i in 0...acc.count - 1 {
    vel.append([0,0,0])
}
for t in 1...acc.count - 1 {
    for j in 0...vel[t].count - 1 {
        vel[t][j] = vel[t-1][j] + acc[t][j] * samplePeriod
    }
    if (stationary[t]==1) {
        vel[t] = [0,0,0]
    }
}

//% Compute integral drift during non-stationary periods
var velDrift:[[Double]] = []
for i in 0...vel.count - 1 {
    velDrift.append([0,0,0])
}
var diff_stationary = diff(X:stationary)
diff_stationary.insert(0, at: 0)
let stationaryStart = find(X:diff_stationary,num:-1)
let stationaryEnd = find(X:diff_stationary,num:1)
for i in 0...stationaryEnd.count-1 {
    var driftRate:[Double] = [0.0,0.0,0.0]
    for  j in 0...driftRate.count-1 {
        driftRate[j] = vel[stationaryEnd[i]-1][j] / Double(stationaryEnd[i] - stationaryStart[i])
    }
    let eNum = Array(1...(stationaryEnd[i] - stationaryStart[i]))
    var drift:[[Double]] = []
    for j in 0...eNum.count-1 {
        drift.append([Double(eNum[j])*driftRate[0],Double(eNum[j])*driftRate[1],Double(eNum[j])*driftRate[2]])
    }
    for j in stationaryStart[i]...stationaryEnd[i]-1 {
        velDrift[j] = drift[j-stationaryStart[i]]
    }
}

//% Remove integral drift
for i in 0...vel.count-1 {
    for j in 0...vel[i].count-1 {
        vel[i][j] = vel[i][j] - velDrift[i][j]
    }
}

//% Plot translational velocity
var velX:[Double] = []
var velY:[Double] = []
var velZ:[Double] = []
for i in 0...vel.count-1 {
    velX.append(vel[i][0])
    velY.append(vel[i][1])
    velZ.append(vel[i][2])
}

//print("velX")
//print(velX)
//print("velY")
//print(velY)
//print("velZ")
//print(velZ)

//% Compute translational position
//% Integrate velocity to yield position
var pos:[[Double]] = []
for i in 0...vel.count-1 {
    pos.append([0.0,0.0,0.0])
}
for t in 1...pos.count-1 {
    for j in 0...pos[t].count-1 {
        pos[t][j] = pos[t-1][j] + vel[t][j] * samplePeriod //% integrate velocity to yield position
    }
}

//% Plot translational position
var posX:[Double] = []
var posY:[Double] = []
var posZ:[Double] = []
for i in 0...pos.count-1 {
    posX.append(pos[i][0])
    posY.append(pos[i][1])
    posZ.append(pos[i][2])
}

print("posX")
print(posX)
print("posY")
print(posY)
print("posZ")
print(posZ)

